"use strict";(self.webpackChunkvulkan_doc=self.webpackChunkvulkan_doc||[]).push([[3013],{2641:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>m,contentTitle:()=>t,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>p});var r=s(4848),i=s(8453);const a={title:"\u7a00\u758f\u8d44\u6e90",description:"\u4ecb\u7ecdvulkan\u7a00\u758f\u8d44\u6e90\u6982\u5ff5",date:new Date("2024-10-04T00:00:00.000Z")},t="\u7a00\u758f\u8d44\u6e90",o={id:"usage/sparse_resources",title:"\u7a00\u758f\u8d44\u6e90",description:"\u4ecb\u7ecdvulkan\u7a00\u758f\u8d44\u6e90\u6982\u5ff5",source:"@site/docs/usage/12-sparse_resources.md",sourceDirName:"usage",slug:"/usage/sparse_resources",permalink:"/usage/sparse_resources",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:12,frontMatter:{title:"\u7a00\u758f\u8d44\u6e90",description:"\u4ecb\u7ecdvulkan\u7a00\u758f\u8d44\u6e90\u6982\u5ff5",date:"2024-10-04T00:00:00.000Z"},sidebar:"VulkanDoc",previous:{title:"\u5185\u5b58\u5206\u914d",permalink:"/usage/memory_allocation"},next:{title:"\u53d7\u4fdd\u62a4\u7684\u5185\u5b58",permalink:"/usage/protected_memory"}},m={},p=[{value:"\u7ed1\u5b9a\u7a00\u758f\u5185\u5b58",id:"\u7ed1\u5b9a\u7a00\u758f\u5185\u5b58",level:2},{value:"\u7a00\u758f\u7f13\u51b2\u533a",id:"\u7a00\u758f\u7f13\u51b2\u533a",level:2},{value:"\u7a00\u758f\u56fe\u50cf",id:"\u7a00\u758f\u56fe\u50cf",level:3},{value:"Mip \u5c3e\u90e8\u533a\u57df",id:"mip-\u5c3e\u90e8\u533a\u57df",level:4},{value:"\u57fa\u672c\u7a00\u758f\u8d44\u6e90\u793a\u4f8b",id:"\u57fa\u672c\u7a00\u758f\u8d44\u6e90\u793a\u4f8b",level:4},{value:"\u9ad8\u7ea7\u7a00\u758f\u8d44\u6e90",id:"\u9ad8\u7ea7\u7a00\u758f\u8d44\u6e90",level:4}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"\u7a00\u758f\u8d44\u6e90",children:"\u7a00\u758f\u8d44\u6e90"})}),"\n",(0,r.jsxs)(n.p,{children:["Vulkan ",(0,r.jsx)(n.a,{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory",children:"\u7a00\u758f\u8d44\u6e90"}),"\u662f\u4e00\u79cd\u521b\u5efa",(0,r.jsx)(n.code,{children:"VkBuffer"}),"\u548c",(0,r.jsx)(n.code,{children:"VkImage"}),"\u5bf9\u8c61\u7684\u65b9\u6cd5\uff0c\u8fd9\u4e9b\u5bf9\u8c61\u53ef\u4ee5\u4e0d\u8fde\u7eed\u5730\u7ed1\u5b9a\u5230\u4e00\u4e2a\u6216\u591a\u4e2a",(0,r.jsx)(n.code,{children:"VkDeviceMemory"}),"\u5206\u914d\u4e0a\uff0c",(0,r.jsx)(n.a,{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-sparseresourcefeatures",children:"Vulkan Spec"}),"\u8be6\u7ec6\u8bf4\u660e\u4e86\u7a00\u758f\u8d44\u6e90\u7684\u8bb8\u591a\u529f\u80fd\u7279\u6027\u3002",(0,r.jsx)(n.a,{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#_sparse_resource_implementation_guidelines",children:"implementation guidelines"}),"\u6307\u51fa\uff0c\u5927\u591a\u6570\u9a71\u52a8\u4f7f\u7528\u7a00\u758f\u8d44\u6e90\u5411\u5e94\u7528\u7a0b\u5e8f\u516c\u5f00\u5185\u5b58\u7684\u7ebf\u6027\u865a\u62df\u5730\u5740\u8303\u56f4\uff0c\u540c\u65f6\u5728\u7ed1\u5b9a\u65f6\u5c06\u6bcf\u4e2a\u7a00\u758f\u5757\u6620\u5c04\u5230\u7269\u7406\u9875\u3002"]}),"\n",(0,r.jsx)(n.h2,{id:"\u7ed1\u5b9a\u7a00\u758f\u5185\u5b58",children:"\u7ed1\u5b9a\u7a00\u758f\u5185\u5b58"}),"\n",(0,r.jsxs)(n.p,{children:["\u4e0e\u8c03\u7528",(0,r.jsx)(n.code,{children:"vkBindBufferMemory()"}),"\u6216",(0,r.jsx)(n.code,{children:"vkBindImageMemory()"}),"\u7ed1\u5b9a\u666e\u901a\u8d44\u6e90\u4e0d\u540c\u7684\u662f\uff0c\u7a00\u758f\u5185\u5b58\u662f\u901a\u8fc7 ",(0,r.jsx)(n.a,{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-resource-binding",children:"queue operation"}),"\u7ed1\u5b9a\u7684\u3002\u8fd9\u6837\u505a\u7684\u4e3b\u8981\u4f18\u70b9\u662f\uff0c\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u5728\u5176\u6574\u4e2a\u751f\u547d\u5468\u671f\u5185\u5c06\u5185\u5b58\u91cd\u65b0\u7ed1\u5b9a\u5230\u4e00\u4e2a\u7a00\u758f\u8d44\u6e90\u3002"]}),"\n",(0,r.jsxs)(n.p,{children:["\u6ce8\u610f\uff0c\u5e94\u7528\u7a0b\u5e8f",(0,r.jsx)(n.strong,{children:"\u5fc5\u987b\u4f7f\u7528"}),"\u540c\u6b65\u539f\u8bed\u6765\u4fdd\u8bc1\u5176\u4ed6\u961f\u5217\u4e0d\u4f1a\u5728\u7ed1\u5b9a\u66f4\u6539\u7684\u540c\u65f6\u8bbf\u95ee\u8fd9\u5757\u5185\u5b58\u3002\u53e6\u5916\u5e94\u7528\u7a0b\u5e8f\u4e0d\u5f97\u8bbf\u95ee\u7ed1\u5b9a\u5230\u5df2\u91ca\u653e\u5185\u5b58\u7684\u8d44\u6e90\u3002"]}),"\n",(0,r.jsx)(n.h2,{id:"\u7a00\u758f\u7f13\u51b2\u533a",children:"\u7a00\u758f\u7f13\u51b2\u533a"}),"\n",(0,r.jsxs)(n.p,{children:["\u4ee5\u4e0b\u793a\u4f8b\u5c55\u793a\u4e86\u7a00\u758f",(0,r.jsx)(n.code,{children:"VkBuffer"}),"\u5728\u5185\u5b58\u4e2d\u7684\u5206\u5e03\u3002\u591a\u6570\u9a71\u52a8\u5b9e\u73b0\u4f7f\u7528 64 KB \u7684",(0,r.jsx)(n.code,{children:"VkBuffer"}),"\u7a00\u758f\u5757\u5927\u5c0f\uff08\u5b9e\u9645\u5927\u5c0f\u5728",(0,r.jsx)(n.code,{children:"VkMemoryRequirements::alignment"}),"\u4e2d\u8fd4\u56de\uff09\u3002"]}),"\n",(0,r.jsxs)(n.p,{children:["\u5047\u8bbe\u6709\u4e00\u4e2a 256 KB \u7684",(0,r.jsx)(n.code,{children:"VkBuffer"}),"\uff0c\u5e94\u7528\u7a0b\u5e8f\u9700\u8981\u5355\u72ec\u66f4\u65b0 3 \u4e2aSection\uff1a"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Section A - 64 KB"}),"\n",(0,r.jsx)(n.li,{children:"Section B - 128 KB"}),"\n",(0,r.jsx)(n.li,{children:"Section C  - 64 KB"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["\u5e94\u7528\u7a0b\u5e8f\u770b\u5230\u7684",(0,r.jsx)(n.code,{children:"VkBuffer"})," \u89c6\u56fe\uff1a"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"sparse_resources_buffer.png",src:s(2995).A+"",width:"608",height:"305"})}),"\n",(0,r.jsx)(n.h3,{id:"\u7a00\u758f\u56fe\u50cf",children:"\u7a00\u758f\u56fe\u50cf"}),"\n",(0,r.jsx)(n.h4,{id:"mip-\u5c3e\u90e8\u533a\u57df",children:"Mip \u5c3e\u90e8\u533a\u57df"}),"\n",(0,r.jsxs)(n.p,{children:["\u7a00\u758f\u56fe\u50cf\u53ef\u7528\u4e8e\u5355\u72ec\u66f4\u65b0 mip levels\uff0c\u4ece\u800c\u4ea7\u751f ",(0,r.jsx)(n.a,{href:"https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#sparsememory-miptail",children:"mip \u5c3e\u90e8\u533a\u57df"}),"\u3002"]}),"\n",(0,r.jsx)(n.h4,{id:"\u57fa\u672c\u7a00\u758f\u8d44\u6e90\u793a\u4f8b",children:"\u57fa\u672c\u7a00\u758f\u8d44\u6e90\u793a\u4f8b"}),"\n",(0,r.jsxs)(n.p,{children:["\u4e0b\u9762\u662f\u4e00\u4e2a\u521b\u5efa\u7a00\u758f\u56fe\u50cf\u5e76\u5c06\u5176\u7ed1\u5b9a\u5230\u7269\u7406\u5185\u5b58\u7684\u793a\u4f8b\uff0c\u521b\u5efa\u4e00\u4e2a\u666e\u901a",(0,r.jsx)(n.code,{children:"VkImage"}),"\u5bf9\u8c61\uff0c\u5206\u914d\u7cbe\u7ec6\u5185\u5b58\u6765\u652f\u6301\u5177\u6709\u591a\u4e2a\u5185\u5b58\u8303\u56f4\u7684\u8d44\u6e90\u3002"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"VkDevice                device;\nVkQueue                 queue;\nVkImage                 sparseImage;\nVkAllocationCallbacks*  pAllocator = NULL;\nVkMemoryRequirements    memoryRequirements = {};\nVkDeviceSize            offset = 0;\nVkSparseMemoryBind      binds[MAX_CHUNKS] = {}; // MAX_CHUNKS is NOT part of Vulkan\nuint32_t                bindCount = 0;\n\n// ...\n\n// Allocate image object\nconst VkImageCreateInfo sparseImageInfo =\n{\n    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,        // sType\n    NULL,                                       // pNext\n    VK_IMAGE_CREATE_SPARSE_BINDING_BIT | ...,   // flags\n    ...\n};\nvkCreateImage(device, &sparseImageInfo, pAllocator, &sparseImage);\n\n// Get memory requirements\nvkGetImageMemoryRequirements(\n    device,\n    sparseImage,\n    &memoryRequirements);\n\n// Bind memory in fine-grained fashion, find available memory ranges\n// from potentially multiple VkDeviceMemory pools.\n// (Illustration purposes only, can be optimized for perf)\nwhile (memoryRequirements.size && bindCount < MAX_CHUNKS)\n{\n    VkSparseMemoryBind* pBind = &binds[bindCount];\n    pBind->resourceOffset = offset;\n\n    AllocateOrGetMemoryRange(\n        device,\n        &memoryRequirements,\n        &pBind->memory,\n        &pBind->memoryOffset,\n        &pBind->size);\n\n    // memory ranges must be sized as multiples of the alignment\n    assert(IsMultiple(pBind->size, memoryRequirements.alignment));\n    assert(IsMultiple(pBind->memoryOffset, memoryRequirements.alignment));\n\n    memoryRequirements.size -= pBind->size;\n    offset                  += pBind->size;\n    bindCount++;\n}\n\n// Ensure entire image has backing\nif (memoryRequirements.size)\n{\n    // Error condition - too many chunks\n}\n\nconst VkSparseImageOpaqueMemoryBindInfo opaqueBindInfo =\n{\n    sparseImage,                                // image\n    bindCount,                                  // bindCount\n    binds                                       // pBinds\n};\n\nconst VkBindSparseInfo bindSparseInfo =\n{\n    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,         // sType\n    NULL,                                       // pNext\n    ...\n    1,                                          // imageOpaqueBindCount\n    &opaqueBindInfo,                            // pImageOpaqueBinds\n    ...\n};\n\n// vkQueueBindSparse is externally synchronized per queue object.\nAcquireQueueOwnership(queue);\n\n// Actually bind memory\nvkQueueBindSparse(queue, 1, &bindSparseInfo, VK_NULL_HANDLE);\n\nReleaseQueueOwnership(queue);\n"})}),"\n",(0,r.jsx)(n.h4,{id:"\u9ad8\u7ea7\u7a00\u758f\u8d44\u6e90",children:"\u9ad8\u7ea7\u7a00\u758f\u8d44\u6e90"}),"\n",(0,r.jsx)(n.p,{children:"\u8fd9\u4e2a\u66f4\u590d\u6742\u4e00\u70b9\u7684\u793a\u4f8b\u521b\u5efa\u989c\u8272\u9644\u4ef6/\u7eb9\u7406\u56fe\u50cf\u6570\u7ec4\uff0c\u5e76\u4ec5\u5c060\u7ea7LOD\u548c\u6240\u9700\u7684\u5143\u6570\u636e\u7ed1\u5b9a\u5230\u7269\u7406\u5185\u5b58\uff1a"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"VkDevice                            device;\nVkQueue                             queue;\nVkImage                             sparseImage;\nVkAllocationCallbacks*              pAllocator = NULL;\nVkMemoryRequirements                memoryRequirements = {};\nuint32_t                            sparseRequirementsCount = 0;\nVkSparseImageMemoryRequirements*    pSparseReqs = NULL;\nVkSparseMemoryBind                  binds[MY_IMAGE_ARRAY_SIZE] = {};\nVkSparseImageMemoryBind             imageBinds[MY_IMAGE_ARRAY_SIZE] = {};\nuint32_t                            bindCount = 0;\n\n// Allocate image object (both renderable and sampleable)\nconst VkImageCreateInfo sparseImageInfo =\n{\n    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,        // sType\n    NULL,                                       // pNext\n    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT | ..., // flags\n    ...\n    VK_FORMAT_R8G8B8A8_UNORM,                   // format\n    ...\n    MY_IMAGE_ARRAY_SIZE,                        // arrayLayers\n    ...\n    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT |\n    VK_IMAGE_USAGE_SAMPLED_BIT,                 // usage\n    ...\n};\nvkCreateImage(device, &sparseImageInfo, pAllocator, &sparseImage);\n\n// Get memory requirements\nvkGetImageMemoryRequirements(\n    device,\n    sparseImage,\n    &memoryRequirements);\n\n// Get sparse image aspect properties\nvkGetImageSparseMemoryRequirements(\n    device,\n    sparseImage,\n    &sparseRequirementsCount,\n    NULL);\n\npSparseReqs = (VkSparseImageMemoryRequirements*)\n    malloc(sparseRequirementsCount * sizeof(VkSparseImageMemoryRequirements));\n\nvkGetImageSparseMemoryRequirements(\n    device,\n    sparseImage,\n    &sparseRequirementsCount,\n    pSparseReqs);\n\n// Bind LOD level 0 and any required metadata to memory\nfor (uint32_t i = 0; i < sparseRequirementsCount; ++i)\n{\n    if (pSparseReqs[i].formatProperties.aspectMask &\n        VK_IMAGE_ASPECT_METADATA_BIT)\n    {\n        // Metadata must not be combined with other aspects\n        assert(pSparseReqs[i].formatProperties.aspectMask ==\n               VK_IMAGE_ASPECT_METADATA_BIT);\n\n        if (pSparseReqs[i].formatProperties.flags &\n            VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT)\n        {\n            VkSparseMemoryBind* pBind = &binds[bindCount];\n            pBind->memorySize = pSparseReqs[i].imageMipTailSize;\n            bindCount++;\n\n            // ... Allocate memory range\n\n            pBind->resourceOffset = pSparseReqs[i].imageMipTailOffset;\n            pBind->memoryOffset = /* allocated memoryOffset */;\n            pBind->memory = /* allocated memory */;\n            pBind->flags = VK_SPARSE_MEMORY_BIND_METADATA_BIT;\n\n        }\n        else\n        {\n            // Need a mip tail region per array layer.\n            for (uint32_t a = 0; a < sparseImageInfo.arrayLayers; ++a)\n            {\n                VkSparseMemoryBind* pBind = &binds[bindCount];\n                pBind->memorySize = pSparseReqs[i].imageMipTailSize;\n                bindCount++;\n\n                // ... Allocate memory range\n\n                pBind->resourceOffset = pSparseReqs[i].imageMipTailOffset +\n                                        (a * pSparseReqs[i].imageMipTailStride);\n\n                pBind->memoryOffset = /* allocated memoryOffset */;\n                pBind->memory = /* allocated memory */\n                pBind->flags = VK_SPARSE_MEMORY_BIND_METADATA_BIT;\n            }\n        }\n    }\n    else\n    {\n        // resource data\n        VkExtent3D lod0BlockSize =\n        {\n            AlignedDivide(\n                sparseImageInfo.extent.width,\n                pSparseReqs[i].formatProperties.imageGranularity.width);\n            AlignedDivide(\n                sparseImageInfo.extent.height,\n                pSparseReqs[i].formatProperties.imageGranularity.height);\n            AlignedDivide(\n                sparseImageInfo.extent.depth,\n                pSparseReqs[i].formatProperties.imageGranularity.depth);\n        }\n        size_t totalBlocks =\n            lod0BlockSize.width *\n            lod0BlockSize.height *\n            lod0BlockSize.depth;\n\n        // Each block is the same size as the alignment requirement,\n        // calculate total memory size for level 0\n        VkDeviceSize lod0MemSize = totalBlocks * memoryRequirements.alignment;\n\n        // Allocate memory for each array layer\n        for (uint32_t a = 0; a < sparseImageInfo.arrayLayers; ++a)\n        {\n            // ... Allocate memory range\n\n            VkSparseImageMemoryBind* pBind = &imageBinds[a];\n            pBind->subresource.aspectMask = pSparseReqs[i].formatProperties.aspectMask;\n            pBind->subresource.mipLevel = 0;\n            pBind->subresource.arrayLayer = a;\n\n            pBind->offset = (VkOffset3D){0, 0, 0};\n            pBind->extent = sparseImageInfo.extent;\n            pBind->memoryOffset = /* allocated memoryOffset */;\n            pBind->memory = /* allocated memory */;\n            pBind->flags = 0;\n        }\n    }\n\n    free(pSparseReqs);\n}\n\nconst VkSparseImageOpaqueMemoryBindInfo opaqueBindInfo =\n{\n    sparseImage,                                // image\n    bindCount,                                  // bindCount\n    binds                                       // pBinds\n};\n\nconst VkSparseImageMemoryBindInfo imageBindInfo =\n{\n    sparseImage,                                // image\n    sparseImageInfo.arrayLayers,                // bindCount\n    imageBinds                                  // pBinds\n};\n\nconst VkBindSparseInfo bindSparseInfo =\n{\n    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,         // sType\n    NULL,                                       // pNext\n    ...\n    1,                                          // imageOpaqueBindCount\n    &opaqueBindInfo,                            // pImageOpaqueBinds\n    1,                                          // imageBindCount\n    &imageBindInfo,                             // pImageBinds\n    ...\n};\n\n// vkQueueBindSparse is externally synchronized per queue object.\nAcquireQueueOwnership(queue);\n\n// Actually bind memory\nvkQueueBindSparse(queue, 1, &bindSparseInfo, VK_NULL_HANDLE);\n\nReleaseQueueOwnership(queue);\n"})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},2995:(e,n,s)=>{s.d(n,{A:()=>r});const r=s.p+"assets/images/sparse_resources_buffer-80ffa76291d1d7f1abab3f7431ea9123.png"},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>o});var r=s(6540);const i={},a=r.createContext(i);function t(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);